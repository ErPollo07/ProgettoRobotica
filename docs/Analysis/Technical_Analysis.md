# TECHNICAL ANALYSIS

## Robot <-> PC Communication

To establish communication between the robot and the PC, an HTTP server has been implemented, hosted locally on the computer.  
The robot sends an HTTP POST request to the server at each significant event in the production line, sending a JSON payload containing the data of the executed operation (e.g., sensor status, coordinates, or action outcomes).

The server receives this data and immediately forwards it to the ThingsBoard platform via an HTTP request, allowing real-time monitoring of the system through IoT dashboards.

## Event Delivery Semantics and Robustness

The communciation between robot, local server. and Thingsboard follows a best-effort delivery model within a local network environment.
Events are trasmitted via HTTP POST without an explicit acknowledgment or  retry mechanism implemented at the robot level. As a result, temporary unavailability of the server or the Thingsboard platform may lead to event loss.
The system does not implement buffering or local persistence of events on either the robot or server side. Duplicate events are not eexplicitly detected or filtered; therefore, in case of retransimission, the same event may be ingested multiple times.
Event ordering is not guaranteed across the entire pipeline. Each event includes a timestamp, which must be considered the primary reference for temporary analysis, KPI computation, and dashboard visualization.
These limitations are considered acceptable within the context of a controlled simulation environment. 

## Robot Code

The software running on the robots is designed to:

1. Handle the robot's operations on the production line materials.
2. Automatically report completed actions to the local server.

For each robot, we have created functions to assist with programming.  
For the Dobot Magician:

```python
def get_sensor_status() -> int:
  """
  Gets the infrared sensor status

  Returns
  ------
  int
    0 if the sensor doesn't detect anything
    1 if the sensor detects anything
  """
  return magicbox.get_infrared_sensor(port=2)["status"] # type: ignore
```

```python
def move_to_point(p: Point, mode: int = 0):
  """
  Move the robot to the coordinate of the Point with a mode

  Params
  ------
  p : Point
    The destination Point
  mode : int
    Specify the mode of movement:
      - 0: make a "jump" from the current position of the robot and the destination point
      - 1: go straight to the destination point
  """
  magician.ptp(mode, p.x, p.y, p.z, 0) # type: ignore
```

```python
def move_to_offpoint(p: Point, off_x: float, off_y: float, off_z: float, mode: int = 0):
  """
  Move the robot to the coordinate of the Point and the offset with a mode.

  Params
  ------
  p : Point
    The destination Point
  off_x : float
    The offset to apply to the x of the destination point
  off_y : float
    The offset to apply to the y of the destination point
  off_z : float
    The offset to apply to the z of the destination point
  mode: int
    Specify the mode of movement:
      - 0: make a "jump" from the current position of the robot and the destination point
      - 1: go straight to the destination point
  """
  magician.ptp(mode, p.x + off_x, p.y + off_y, p.z + off_z, 0) # type: ignore
```

```python
def set_conv_speed(speed: int):
  """
  Set the conveyor speed.

  Params
  ------
  speed : int
    The speed to set to the conveyor.
  """
  magicbox.set_converyor(index=magicbox.STP1, enable=True, speed=speed) # type: ignore
```

```python
def suck(state: bool):
  """
  Set the suction cup on or off.

  Params
  ------
  state : bool
    The state that needs to be applied to the suction cup.
  """
  magician.set_endeffector_suctioncup(enable=state, on=state) # type: ignore
```

For the magician lite robot:

```python
def move_to_point(p: Point, mode: int = 0):
  m_lite.set_ptpcmd(ptp_mode=mode, x=p.x, y=p.y, z=p.z, r=0)# type: ignore
```

```python
def move_to_offpoint(p: Point, off_x: float, off_y: float, off_z: float, mode: int = 0):
  m_lite.set_ptpcmd(ptp_mode=mode, x=p.x + off_x, y=p.y + off_y, z=p.z + off_z, r=0) # type: ignore
```

```python
def suck(state: bool):
  m_lite.set_endeffector_suctioncup(enable=state, on=state) # type: ignore
```

## Server Code

The server is implemented as a local web server within the network.  
Its main function is to receive the HTTP requests sent by the robots, process the JSON payloads, and forward them to ThingsBoard or other internal endpoints.

## Logical Data Model and Event Structure

Although Thingsboard internally manages data using telemetry, attributes , and events, the backend architecture can be described through a logical data model composed of the following conceptual entities: 

- **Device (robot)**: physical robot uniquely indentified within the platform
- **Sensor**: logical data source associated with a device.
- **Event**: discrete occurence generated by a robot action (e.g., pick, place, detection).
- **Anomaly/Alarm**: Abnormal condition detected through  threshold violations on rule evaluation.
-**KPI**: derived metrics computed from telemetry and event streams.

Each event sent to the platform follows a minimal common structure to ensure data consistency and ease of analysis:

- 'device_id': unique identifier of  the event source
- 'timestamp': time at which the event was generated
- 'event_type': semantic classification of the event
- 'payload': event-specific data (e.g., sensor values, coordinates, status)


## Data Categories in Thingsboard
Thingsboard organizes the incoming data into distinct logical categories, each saving a specific functional role within the monitoring and analysis pipeline.

- **Telemetry**: is used to store time-series data generated by the robots and sensors, such as sensor readings, coordinates, conveyor speed and execution timestamps. This data represents the primary source for real-time visualization and historical analysis.
- **Attributes**: are used to represent static or slowly changing metdata associated with devices, including robot identifiers, configuration parameters and descriptive properties. Attributes provide contextual information that complements telemetry data dn supports device management.
- **Events and Alarms**: represent discrete occurences  and abnormal conditions detected either directly from robot-generated events or through rule-based evaulation on telemetry streams. These data are primarly used for anomaly detection, systems are monitoring, and high-level operational awareness.

The clear separation between telemetry, attributes and events allows the platform to support real-time dashboards, KPI computation, and rule-based logic whgile maintaining semantic clarity across the different types of data.


## Configuration and Parametrization

The operational parameters relevant to the simulation (such as conveyor speed, timing thresholds, and sensor sampling or data transmission rates) are currently defined directly within the robot control code and server logic. These parameters are static and hard-coded, and no external configuration files or environment-based parameterization mechanisms are provided. As a result, changes to operational settings require code modifications and redeployment. This approach reduces the reproducibility of the simulation across different runs and limits the traceability of configuration changes. Nevertheless, it is considered acceptable within the context of a controlled academic simulation, where system behavior is evaluated under fixed and known conditions.


Go back to the [functional analysis](./Functional_Analysis.md)

Go back to the [index](./Analysis.md.md)
